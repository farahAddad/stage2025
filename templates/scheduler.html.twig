<!-- Scheduler JavaScript pour TOUTES les pages -->
<script>
/**
 * Scheduler Console - Affiche le vrai statut des sessions toutes les 40 secondes
 * DISPONIBLE SUR TOUTES LES PAGES
 */

class SchedulerConsole {
    constructor() {
        this.interval = 40000; // 40 secondes en millisecondes
        this.isRunning = false;
        this.executionCount = 0;
        this.startTime = new Date();
        this.page = '{{ app.request.get('_route') }}';
        
        this.init();
    }
    
    init() {
        console.log('üöÄ SCHEDULER CONSOLE - Initialis√© sur la page:', this.page);
        console.log(`‚è∞ Intervalle: ${this.interval / 1000} secondes`);
        console.log(`üïê D√©marrage: ${this.startTime.toLocaleTimeString()}`);
        console.log(`üìç Page: ${this.page}`);
        console.log(`üîç V√©rification des vraies sessions en base de donn√©es...`);
        
        this.start();
    }
    
    start() {
        if (this.isRunning) {
            console.warn('‚ö†Ô∏è Le scheduler est d√©j√† en cours d\'ex√©cution');
            return;
        }
        
        this.isRunning = true;
        console.log('‚úÖ Scheduler d√©marr√© - V√©rification des sessions toutes les 40 secondes');
        
        // Premi√®re ex√©cution imm√©diate
        this.execute();
        
        // Puis toutes les 40 secondes
        this.intervalId = setInterval(() => {
            this.execute();
        }, this.interval);
    }
    
    stop() {
        if (!this.isRunning) {
            console.warn('‚ö†Ô∏è Le scheduler n\'est pas en cours d\'ex√©cution');
            return;
        }
        
        this.isRunning = false;
        clearInterval(this.intervalId);
        console.log('üõë Scheduler arr√™t√©');
    }
    
    async execute() {
        this.executionCount++;
        const now = new Date();
        const elapsedTime = Math.floor((now - this.startTime) / 1000);
        
        console.log('üîÑ SCHEDULER ACTIF - Ex√©cution #' + this.executionCount);
        console.log(`üïê Heure actuelle: ${now.toLocaleTimeString()}`);
        console.log(`‚è±Ô∏è Temps √©coul√© depuis le d√©but: ${elapsedTime}s`);
        console.log(`üîç V√©rification des sessions en cours...`);
        
        try {
            // 1. D'abord, r√©cup√©rer le statut des sessions
            const response = await fetch('/admin/sessions-status', {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                }
            });
            
            if (response.ok) {
                const data = await response.json();
                this.afficherResultats(data);
                
                // 2. Si il y a des changements √† effectuer, ex√©cuter le vrai scheduler
                if (data.details.length > 0) {
                    console.log('üöÄ Ex√©cution du vrai scheduler Symfony pour modifier les statuts...');
                    await this.executerSchedulerSymfony();
                }
            } else {
                console.error('‚ùå Erreur lors de la r√©cup√©ration du statut des sessions');
            }
        } catch (error) {
            console.error('‚ùå Erreur r√©seau:', error);
            console.log('‚ö†Ô∏è Impossible de r√©cup√©rer le statut des sessions - Erreur r√©seau');
        }
        
        console.log(`‚úÖ SCHEDULER TERMIN√â - Prochaine ex√©cution dans 40 secondes`);
        console.log('---');
    }
    
    async executerSchedulerSymfony() {
        try {
            console.log('‚ö° Appel du scheduler Symfony...');
            
            // Appeler le vrai scheduler Symfony via une route
            const response = await fetch('/admin/execute-scheduler', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                }
            });
            
            if (response.ok) {
                const result = await response.json();
                console.log('‚úÖ Scheduler Symfony ex√©cut√© avec succ√®s !');
                console.log('üìä R√©sultats:', result);
                
                // Afficher les d√©tails des notifications
                if (result.notifications_envoyees > 0) {
                    console.log(`üìß Notifications envoy√©es: ${result.notifications_envoyees}`);
                    if (result.details) {
                        result.details.forEach(detail => {
                            console.log(`   ‚Ä¢ ${detail}`);
                        });
                    }
                }
                
                // Attendre un peu puis re-v√©rifier le statut
                setTimeout(async () => {
                    console.log('üîÑ Re-v√©rification du statut apr√®s modification...');
                    const recheckResponse = await fetch('/admin/sessions-status');
                    if (recheckResponse.ok) {
                        const recheckData = await recheckResponse.json();
                        console.log('üìã Nouveau statut des sessions:');
                        this.afficherResultats(recheckData);
                    }
                }, 2000); // Attendre 2 secondes
                
            } else {
                console.error('‚ùå Erreur lors de l\'ex√©cution du scheduler Symfony');
            }
        } catch (error) {
            console.error('‚ùå Erreur lors de l\'ex√©cution du scheduler:', error);
        }
    }
    
    afficherResultats(data) {
        console.log(`üìä Sessions v√©rifi√©es: ${data.sessions_verifiees}`);
        console.log(`üïê Timestamp: ${data.timestamp}`);
        
        // Sessions √† d√©marrer
        if (data.sessions_a_demarrer.length > 0) {
            console.log(`üü¢ Sessions √† d√©marrer (${data.sessions_a_demarrer.length}):`);
            data.sessions_a_demarrer.forEach(session => {
                if (session.doit_changer) {
                    console.log(`   ‚úÖ Session "${session.titre}" (ID: ${session.id})`);
                    console.log(`      Status: "${session.status_actuel}" ‚Üí "${session.nouveau_status}"`);
                    console.log(`      Raison: ${session.raison}`);
                    console.log(`      Date d√©but: ${session.date_debut}`);
                } else {
                    console.log(`   ‚è≥ Session "${session.titre}" (ID: ${session.id})`);
                    console.log(`      Status: "${session.status_actuel}" (pas de changement)`);
                    console.log(`      Raison: ${session.raison}`);
                    console.log(`      Date d√©but: ${session.date_debut}`);
                }
            });
        } else {
            console.log('‚ÑπÔ∏è Aucune session √† d√©marrer');
        }
        
        // Sessions √† terminer
        if (data.sessions_a_terminer.length > 0) {
            console.log(`üî¥ Sessions √† terminer (${data.sessions_a_terminer.length}):`);
            data.sessions_a_terminer.forEach(session => {
                if (session.doit_changer) {
                    console.log(`   ‚úÖ Session "${session.titre}" (ID: ${session.id})`);
                    console.log(`      Status: "${session.status_actuel}" ‚Üí "${session.nouveau_status}"`);
                    console.log(`      Raison: ${session.raison}`);
                    console.log(`      Date fin: ${session.date_fin}`);
                } else {
                    console.log(`   ‚è≥ Session "${session.titre}" (ID: ${session.id})`);
                    console.log(`      Status: "${session.status_actuel}" (pas de changement)`);
                    console.log(`      Raison: ${session.raison}`);
                    console.log(`      Date fin: ${session.date_fin}`);
                }
            });
        } else {
            console.log('‚ÑπÔ∏è Aucune session √† terminer');
        }
        
        // R√©sum√© des changements
        if (data.details.length > 0) {
            console.log(`üîÑ Changements √† effectuer (${data.details.length}):`);
            data.details.forEach(detail => {
                console.log(`   ‚Ä¢ ${detail}`);
            });
        } else {
            console.log('‚ÑπÔ∏è Aucun changement de statut n√©cessaire pour le moment');
        }
    }
    
    getStatus() {
        return {
            isRunning: this.isRunning,
            executionCount: this.executionCount,
            startTime: this.startTime,
            interval: this.interval,
            page: this.page
        };
    }
}

// Initialiser le scheduler quand la page est charg√©e
document.addEventListener('DOMContentLoaded', function() {
    // Cr√©er une instance globale pour pouvoir la contr√¥ler depuis la console
    window.schedulerConsole = new SchedulerConsole();
    
    // Afficher les commandes utiles dans la console
    console.log('üí° Commandes disponibles:');
    console.log('  - schedulerConsole.stop() : Arr√™ter le scheduler');
    console.log('  - schedulerConsole.start() : Red√©marrer le scheduler');
    console.log('  - schedulerConsole.getStatus() : Voir le statut');
    console.log('  - schedulerConsole.execute() : Ex√©cuter imm√©diatement');
});

// Exposer la classe globalement pour utilisation avanc√©e
window.SchedulerConsole = SchedulerConsole;
</script>
